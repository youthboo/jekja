{"ast":null,"code":"import util from './util.mjs';\nimport mat from './mat.mjs';\nimport params from './params.mjs';\nconst util_regression = {};\n\n/**\n * Initialize new arrays and initialize Kalman filter for regressions.\n */\nutil_regression.InitRegression = function () {\n  var dataWindow = 700;\n  var trailDataWindow = 10;\n  this.ridgeParameter = Math.pow(10, -5);\n  this.errorXArray = new util.DataWindow(dataWindow);\n  this.errorYArray = new util.DataWindow(dataWindow);\n  this.screenXClicksArray = new util.DataWindow(dataWindow);\n  this.screenYClicksArray = new util.DataWindow(dataWindow);\n  this.eyeFeaturesClicks = new util.DataWindow(dataWindow);\n\n  //sets to one second worth of cursor trail\n  this.trailTime = 1000;\n  this.trailDataWindow = this.trailTime / params.moveTickSize;\n  this.screenXTrailArray = new util.DataWindow(trailDataWindow);\n  this.screenYTrailArray = new util.DataWindow(trailDataWindow);\n  this.eyeFeaturesTrail = new util.DataWindow(trailDataWindow);\n  this.trailTimes = new util.DataWindow(trailDataWindow);\n  this.dataClicks = new util.DataWindow(dataWindow);\n  this.dataTrail = new util.DataWindow(trailDataWindow);\n\n  // Initialize Kalman filter [20200608 xk] what do we do about parameters?\n  // [20200611 xk] unsure what to do w.r.t. dimensionality of these matrices. So far at least\n  //               by my own anecdotal observation a 4x1 x vector seems to work alright\n  var F = [[1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0], [0, 0, 0, 1]];\n\n  //Parameters Q and R may require some fine tuning\n  var Q = [[1 / 4, 0, 1 / 2, 0], [0, 1 / 4, 0, 1 / 2], [1 / 2, 0, 1, 0], [0, 1 / 2, 0, 1]]; // * delta_t\n  var delta_t = 1 / 10; // The amount of time between frames\n  Q = mat.multScalar(Q, delta_t);\n  var H = [[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0]];\n  var H = [[1, 0, 0, 0], [0, 1, 0, 0]];\n  var pixel_error = 47; //We will need to fine tune this value [20200611 xk] I just put a random value here\n\n  //This matrix represents the expected measurement error\n  var R = mat.multScalar(mat.identity(2), pixel_error);\n  var P_initial = mat.multScalar(mat.identity(4), 0.0001); //Initial covariance matrix\n  var x_initial = [[500], [500], [0], [0]]; // Initial measurement matrix\n\n  this.kalman = new util_regression.KalmanFilter(F, H, Q, R, P_initial, x_initial);\n};\n\n/**\n * Kalman Filter constructor\n * Kalman filters work by reducing the amount of noise in a models.\n * https://blog.cordiner.net/2011/05/03/object-tracking-using-a-kalman-filter-matlab/\n *\n * @param {Array.<Array.<Number>>} F - transition matrix\n * @param {Array.<Array.<Number>>} Q - process noise matrix\n * @param {Array.<Array.<Number>>} H - maps between measurement vector and noise matrix\n * @param {Array.<Array.<Number>>} R - defines measurement error of the device\n * @param {Array} P_initial - the initial state\n * @param {Array} X_initial - the initial state of the device\n */\nutil_regression.KalmanFilter = function (F, H, Q, R, P_initial, X_initial) {\n  this.F = F; // State transition matrix\n  this.Q = Q; // Process noise matrix\n  this.H = H; // Transformation matrix\n  this.R = R; // Measurement Noise\n  this.P = P_initial; //Initial covariance matrix\n  this.X = X_initial; //Initial guess of measurement\n};\n\n/**\n * Get Kalman next filtered value and update the internal state\n * @param {Array} z - the new measurement\n * @return {Array}\n */\nutil_regression.KalmanFilter.prototype.update = function (z) {\n  // Here, we define all the different matrix operations we will need\n  var {\n    add,\n    sub,\n    mult,\n    inv,\n    identity,\n    transpose\n  } = mat;\n  //TODO cache variables like the transpose of H\n\n  // prediction: X = F * X  |  P = F * P * F' + Q\n  var X_p = mult(this.F, this.X); //Update state vector\n  var P_p = add(mult(mult(this.F, this.P), transpose(this.F)), this.Q); //Predicted covaraince\n\n  //Calculate the update values\n  z = transpose([z]);\n  var y = sub(z, mult(this.H, X_p)); // This is the measurement error (between what we expect and the actual value)\n  var S = add(mult(mult(this.H, P_p), transpose(this.H)), this.R); //This is the residual covariance (the error in the covariance)\n\n  // kalman multiplier: K = P * H' * (H * P * H' + R)^-1\n  var K = mult(P_p, mult(transpose(this.H), inv(S))); //This is the Optimal Kalman Gain\n\n  //We need to change Y into it's column vector form\n  for (var i = 0; i < y.length; i++) {\n    y[i] = [y[i]];\n  }\n\n  //Now we correct the internal values of the model\n  // correction: X = X + K * (m - H * X)  |  P = (I - K * H) * P\n  this.X = add(X_p, mult(K, y));\n  this.P = mult(sub(identity(K.length), mult(K, this.H)), P_p);\n  return transpose(mult(this.H, this.X))[0]; //Transforms the predicted state back into it's measurement form\n};\n\n/**\n * Performs ridge regression, according to the Weka code.\n * @param {Array} y - corresponds to screen coordinates (either x or y) for each of n click events\n * @param {Array.<Array.<Number>>} X - corresponds to gray pixel features (120 pixels for both eyes) for each of n clicks\n * @param {Array} k - ridge parameter\n * @return{Array} regression coefficients\n */\nutil_regression.ridge = function (y, X, k) {\n  var nc = X[0].length;\n  var m_Coefficients = new Array(nc);\n  var xt = mat.transpose(X);\n  var solution = new Array();\n  var success = true;\n  do {\n    var ss = mat.mult(xt, X);\n    // Set ridge regression adjustment\n    for (var i = 0; i < nc; i++) {\n      ss[i][i] = ss[i][i] + k;\n    }\n\n    // Carry out the regression\n    var bb = mat.mult(xt, y);\n    for (var i = 0; i < nc; i++) {\n      m_Coefficients[i] = bb[i][0];\n    }\n    try {\n      var n = m_Coefficients.length !== 0 ? m_Coefficients.length / m_Coefficients.length : 0;\n      if (m_Coefficients.length * n !== m_Coefficients.length) {\n        console.log('Array length must be a multiple of m');\n      }\n      solution = mat.solve(ss, bb);\n      for (var i = 0; i < nc; i++) {\n        m_Coefficients[i] = solution[i];\n      }\n      success = true;\n    } catch (ex) {\n      k *= 10;\n      console.log(ex);\n      success = false;\n    }\n  } while (!success);\n  return m_Coefficients;\n};\n\n/**\n * Add given data to current data set then,\n * replace current data member with given data\n * @param {Array.<Object>} data - The data to set\n */\nutil_regression.setData = function (data) {\n  for (var i = 0; i < data.length; i++) {\n    // Clone data array\n    var leftData = new Uint8ClampedArray(data[i].eyes.left.patch.data);\n    var rightData = new Uint8ClampedArray(data[i].eyes.right.patch.data);\n    // Duplicate ImageData object\n    data[i].eyes.left.patch = new ImageData(leftData, data[i].eyes.left.width, data[i].eyes.left.height);\n    data[i].eyes.right.patch = new ImageData(rightData, data[i].eyes.right.width, data[i].eyes.right.height);\n\n    // Add those data objects to model\n    this.addData(data[i].eyes, data[i].screenPos, data[i].type);\n  }\n};\n\n//not used ?!\n//TODO: still usefull ???\n/**\n *\n * @returns {Number}\n */\nutil_regression.getCurrentFixationIndex = function () {\n  var index = 0;\n  var recentX = this.screenXTrailArray.get(0);\n  var recentY = this.screenYTrailArray.get(0);\n  for (var i = this.screenXTrailArray.length - 1; i >= 0; i--) {\n    var currX = this.screenXTrailArray.get(i);\n    var currY = this.screenYTrailArray.get(i);\n    var euclideanDistance = Math.sqrt(Math.pow(currX - recentX, 2) + Math.pow(currY - recentY, 2));\n    if (euclideanDistance > 72) {\n      return i + 1;\n    }\n  }\n  return i;\n};\nutil_regression.addData = function (eyes, screenPos, type) {\n  if (!eyes) {\n    return;\n  }\n  //not doing anything with blink at present\n  // if (eyes.left.blink || eyes.right.blink) {\n  //     return;\n  // }\n  if (type === 'click') {\n    this.screenXClicksArray.push([screenPos[0]]);\n    this.screenYClicksArray.push([screenPos[1]]);\n    this.eyeFeaturesClicks.push(util.getEyeFeats(eyes));\n    this.dataClicks.push({\n      'eyes': eyes,\n      'screenPos': screenPos,\n      'type': type\n    });\n  } else if (type === 'move') {\n    this.screenXTrailArray.push([screenPos[0]]);\n    this.screenYTrailArray.push([screenPos[1]]);\n    this.eyeFeaturesTrail.push(util.getEyeFeats(eyes));\n    this.trailTimes.push(performance.now());\n    this.dataTrail.push({\n      'eyes': eyes,\n      'screenPos': screenPos,\n      'type': type\n    });\n  }\n\n  // [20180730 JT] Why do we do this? It doesn't return anything...\n  // But as JS is pass by reference, it still affects it.\n  //\n  // Causes problems for when we want to call 'addData' twice in a row on the same object, but perhaps with different screenPos or types (think multiple interactions within one video frame)\n  //eyes.left.patch = Array.from(eyes.left.patch.data);\n  //eyes.right.patch = Array.from(eyes.right.patch.data);\n};\nexport default util_regression;","map":{"version":3,"names":["util","mat","params","util_regression","InitRegression","dataWindow","trailDataWindow","ridgeParameter","Math","pow","errorXArray","DataWindow","errorYArray","screenXClicksArray","screenYClicksArray","eyeFeaturesClicks","trailTime","moveTickSize","screenXTrailArray","screenYTrailArray","eyeFeaturesTrail","trailTimes","dataClicks","dataTrail","F","Q","delta_t","multScalar","H","pixel_error","R","identity","P_initial","x_initial","kalman","KalmanFilter","X_initial","P","X","prototype","update","z","add","sub","mult","inv","transpose","X_p","P_p","y","S","K","i","length","ridge","k","nc","m_Coefficients","Array","xt","solution","success","ss","bb","n","console","log","solve","ex","setData","data","leftData","Uint8ClampedArray","eyes","left","patch","rightData","right","ImageData","width","height","addData","screenPos","type","getCurrentFixationIndex","index","recentX","get","recentY","currX","currY","euclideanDistance","sqrt","push","getEyeFeats","performance","now"],"sources":["/Users/aqwerrrx/Desktop/special1/frontend/node_modules/webgazer/src/util_regression.mjs"],"sourcesContent":["import util from './util.mjs';\nimport mat from './mat.mjs';\nimport params from './params.mjs';\n\nconst util_regression = {};\n\n\n/**\n * Initialize new arrays and initialize Kalman filter for regressions.\n */\nutil_regression.InitRegression = function() {\n  var dataWindow = 700;\n  var trailDataWindow = 10;\n  this.ridgeParameter = Math.pow(10,-5);\n  this.errorXArray = new util.DataWindow(dataWindow);\n  this.errorYArray = new util.DataWindow(dataWindow);\n\n\n  this.screenXClicksArray = new util.DataWindow(dataWindow);\n  this.screenYClicksArray = new util.DataWindow(dataWindow);\n  this.eyeFeaturesClicks = new util.DataWindow(dataWindow);\n\n  //sets to one second worth of cursor trail\n  this.trailTime = 1000;\n  this.trailDataWindow = this.trailTime / params.moveTickSize;\n  this.screenXTrailArray = new util.DataWindow(trailDataWindow);\n  this.screenYTrailArray = new util.DataWindow(trailDataWindow);\n  this.eyeFeaturesTrail = new util.DataWindow(trailDataWindow);\n  this.trailTimes = new util.DataWindow(trailDataWindow);\n\n  this.dataClicks = new util.DataWindow(dataWindow);\n  this.dataTrail = new util.DataWindow(trailDataWindow);\n\n  // Initialize Kalman filter [20200608 xk] what do we do about parameters?\n  // [20200611 xk] unsure what to do w.r.t. dimensionality of these matrices. So far at least\n  //               by my own anecdotal observation a 4x1 x vector seems to work alright\n  var F = [ [1, 0, 1, 0],\n    [0, 1, 0, 1],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1]];\n\n  //Parameters Q and R may require some fine tuning\n  var Q = [ [1/4, 0,    1/2, 0],\n    [0,   1/4,  0,   1/2],\n    [1/2, 0,    1,   0],\n    [0,  1/2,  0,   1]];// * delta_t\n  var delta_t = 1/10; // The amount of time between frames\n  Q = mat.multScalar(Q, delta_t);\n\n  var H = [ [1, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 1, 0, 0]];\n  var H = [ [1, 0, 0, 0],\n    [0, 1, 0, 0]];\n  var pixel_error = 47; //We will need to fine tune this value [20200611 xk] I just put a random value here\n\n  //This matrix represents the expected measurement error\n  var R = mat.multScalar(mat.identity(2), pixel_error);\n\n  var P_initial = mat.multScalar(mat.identity(4), 0.0001); //Initial covariance matrix\n  var x_initial = [[500], [500], [0], [0]]; // Initial measurement matrix\n\n  this.kalman = new util_regression.KalmanFilter(F, H, Q, R, P_initial, x_initial);\n}\n\n/**\n * Kalman Filter constructor\n * Kalman filters work by reducing the amount of noise in a models.\n * https://blog.cordiner.net/2011/05/03/object-tracking-using-a-kalman-filter-matlab/\n *\n * @param {Array.<Array.<Number>>} F - transition matrix\n * @param {Array.<Array.<Number>>} Q - process noise matrix\n * @param {Array.<Array.<Number>>} H - maps between measurement vector and noise matrix\n * @param {Array.<Array.<Number>>} R - defines measurement error of the device\n * @param {Array} P_initial - the initial state\n * @param {Array} X_initial - the initial state of the device\n */\nutil_regression.KalmanFilter = function(F, H, Q, R, P_initial, X_initial) {\n    this.F = F; // State transition matrix\n    this.Q = Q; // Process noise matrix\n    this.H = H; // Transformation matrix\n    this.R = R; // Measurement Noise\n    this.P = P_initial; //Initial covariance matrix\n    this.X = X_initial; //Initial guess of measurement\n};\n\n/**\n * Get Kalman next filtered value and update the internal state\n * @param {Array} z - the new measurement\n * @return {Array}\n */\nutil_regression.KalmanFilter.prototype.update = function(z) {\n    // Here, we define all the different matrix operations we will need\n    var {\n        add, sub, mult, inv, identity, transpose,\n    } = mat;\n    //TODO cache variables like the transpose of H\n\n    // prediction: X = F * X  |  P = F * P * F' + Q\n    var X_p = mult(this.F, this.X); //Update state vector\n    var P_p = add(mult(mult(this.F,this.P), transpose(this.F)), this.Q); //Predicted covaraince\n\n    //Calculate the update values\n    z = transpose([z])\n    var y = sub(z, mult(this.H, X_p)); // This is the measurement error (between what we expect and the actual value)\n    var S = add(mult(mult(this.H, P_p), transpose(this.H)), this.R); //This is the residual covariance (the error in the covariance)\n\n    // kalman multiplier: K = P * H' * (H * P * H' + R)^-1\n    var K = mult(P_p, mult(transpose(this.H), inv(S))); //This is the Optimal Kalman Gain\n\n    //We need to change Y into it's column vector form\n    for(var i = 0; i < y.length; i++){\n        y[i] = [y[i]];\n    }\n\n    //Now we correct the internal values of the model\n    // correction: X = X + K * (m - H * X)  |  P = (I - K * H) * P\n    this.X = add(X_p, mult(K, y));\n    this.P = mult(sub(identity(K.length), mult(K,this.H)), P_p);\n    return transpose(mult(this.H, this.X))[0]; //Transforms the predicted state back into it's measurement form\n};\n\n/**\n * Performs ridge regression, according to the Weka code.\n * @param {Array} y - corresponds to screen coordinates (either x or y) for each of n click events\n * @param {Array.<Array.<Number>>} X - corresponds to gray pixel features (120 pixels for both eyes) for each of n clicks\n * @param {Array} k - ridge parameter\n * @return{Array} regression coefficients\n */\nutil_regression.ridge = function(y, X, k){\n    var nc = X[0].length;\n    var m_Coefficients = new Array(nc);\n    var xt = mat.transpose(X);\n    var solution = new Array();\n    var success = true;\n    do{\n        var ss = mat.mult(xt,X);\n        // Set ridge regression adjustment\n        for (var i = 0; i < nc; i++) {\n            ss[i][i] = ss[i][i] + k;\n        }\n\n        // Carry out the regression\n        var bb = mat.mult(xt,y);\n        for(var i = 0; i < nc; i++) {\n            m_Coefficients[i] = bb[i][0];\n        }\n        try{\n            var n = (m_Coefficients.length !== 0 ? m_Coefficients.length/m_Coefficients.length: 0);\n            if (m_Coefficients.length*n !== m_Coefficients.length){\n                console.log('Array length must be a multiple of m')\n            }\n            solution = mat.solve(ss, bb);\n\n            for (var i = 0; i < nc; i++){\n                m_Coefficients[i] = solution[i];\n            }\n            success = true;\n        }\n        catch (ex){\n            k *= 10;\n            console.log(ex);\n            success = false;\n        }\n    } while (!success);\n    return m_Coefficients;\n}\n\n/**\n * Add given data to current data set then,\n * replace current data member with given data\n * @param {Array.<Object>} data - The data to set\n */\nutil_regression.setData = function(data) {\n  for (var i = 0; i < data.length; i++) {\n    // Clone data array\n    var leftData = new Uint8ClampedArray(data[i].eyes.left.patch.data);\n    var rightData = new Uint8ClampedArray(data[i].eyes.right.patch.data);\n    // Duplicate ImageData object\n    data[i].eyes.left.patch = new ImageData(leftData, data[i].eyes.left.width, data[i].eyes.left.height);\n    data[i].eyes.right.patch = new ImageData(rightData, data[i].eyes.right.width, data[i].eyes.right.height);\n\n    // Add those data objects to model\n    this.addData(data[i].eyes, data[i].screenPos, data[i].type);\n  }\n};\n\n\n//not used ?!\n//TODO: still usefull ???\n/**\n *\n * @returns {Number}\n */\nutil_regression.getCurrentFixationIndex = function() {\n  var index = 0;\n  var recentX = this.screenXTrailArray.get(0);\n  var recentY = this.screenYTrailArray.get(0);\n  for (var i = this.screenXTrailArray.length - 1; i >= 0; i--) {\n    var currX = this.screenXTrailArray.get(i);\n    var currY = this.screenYTrailArray.get(i);\n    var euclideanDistance = Math.sqrt(Math.pow((currX-recentX),2)+Math.pow((currY-recentY),2));\n    if (euclideanDistance > 72){\n      return i+1;\n    }\n  }\n  return i;\n}\n\nutil_regression.addData = function(eyes, screenPos, type) {\n    if (!eyes) {\n        return;\n    }\n    //not doing anything with blink at present\n    // if (eyes.left.blink || eyes.right.blink) {\n    //     return;\n    // }\n    if (type === 'click') {\n        this.screenXClicksArray.push([screenPos[0]]);\n        this.screenYClicksArray.push([screenPos[1]]);\n        this.eyeFeaturesClicks.push(util.getEyeFeats(eyes));\n        this.dataClicks.push({'eyes':eyes, 'screenPos':screenPos, 'type':type});\n    } else if (type === 'move') {\n        this.screenXTrailArray.push([screenPos[0]]);\n        this.screenYTrailArray.push([screenPos[1]]);\n\n        this.eyeFeaturesTrail.push(util.getEyeFeats(eyes));\n        this.trailTimes.push(performance.now());\n        this.dataTrail.push({'eyes':eyes, 'screenPos':screenPos, 'type':type});\n    }\n\n    // [20180730 JT] Why do we do this? It doesn't return anything...\n    // But as JS is pass by reference, it still affects it.\n    //\n    // Causes problems for when we want to call 'addData' twice in a row on the same object, but perhaps with different screenPos or types (think multiple interactions within one video frame)\n    //eyes.left.patch = Array.from(eyes.left.patch.data);\n    //eyes.right.patch = Array.from(eyes.right.patch.data);\n};\n\nexport default util_regression;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}