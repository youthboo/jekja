{"ast":null,"code":"import * as faceLandmarksDetection from '@tensorflow-models/face-landmarks-detection';\n\n/**\n * Constructor of TFFaceMesh object\n * @constructor\n * */\nconst TFFaceMesh = function () {\n  //Backend options are webgl, wasm, and CPU.\n  //For recent laptops WASM is better than WebGL.\n  this.model = faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages.mediapipeFacemesh, {\n    maxFaces: 1\n  });\n  this.predictionReady = false;\n};\n\n// Global variable for face landmark positions array\nTFFaceMesh.prototype.positionsArray = null;\n\n/**\n * Isolates the two patches that correspond to the user's eyes\n * @param  {Object} video - the video element itself\n * @param  {Canvas} imageCanvas - canvas corresponding to the webcam stream\n * @param  {Number} width - of imageCanvas\n * @param  {Number} height - of imageCanvas\n * @return {Object} the two eye-patches, first left, then right eye\n */\nTFFaceMesh.prototype.getEyePatches = async function (video, imageCanvas, width, height) {\n  if (imageCanvas.width === 0) {\n    return null;\n  }\n\n  // Load the MediaPipe facemesh model.\n  const model = await this.model;\n\n  // Pass in a video stream (or an image, canvas, or 3D tensor) to obtain an\n  // array of detected faces from the MediaPipe graph.\n  const predictions = await model.estimateFaces({\n    input: video,\n    returnTensors: false,\n    flipHorizontal: false,\n    predictIrises: false\n  });\n  if (predictions.length == 0) {\n    return false;\n  }\n\n  // Save positions to global variable\n  this.positionsArray = predictions[0].scaledMesh;\n  const prediction = predictions[0];\n  const positions = this.positionsArray;\n  const {\n    scaledMesh\n  } = predictions[0];\n  // Keypoints indexes are documented at\n  // https://github.com/tensorflow/tfjs-models/blob/118d4727197d4a21e2d4691e134a7bc30d90deee/face-landmarks-detection/mesh_map.jpg\n  // https://stackoverflow.com/questions/66649492/how-to-get-specific-landmark-of-face-like-lips-or-eyes-using-tensorflow-js-face\n  const [leftBBox, rightBBox] = [\n  // left\n  {\n    eyeTopArc: prediction.annotations.leftEyeUpper0,\n    eyeBottomArc: prediction.annotations.leftEyeLower0\n  },\n  // right\n  {\n    eyeTopArc: prediction.annotations.rightEyeUpper0,\n    eyeBottomArc: prediction.annotations.rightEyeLower0\n  }].map(({\n    eyeTopArc,\n    eyeBottomArc\n  }) => {\n    const topLeftOrigin = {\n      x: Math.round(Math.min(...eyeTopArc.map(v => v[0]))),\n      y: Math.round(Math.min(...eyeTopArc.map(v => v[1])))\n    };\n    const bottomRightOrigin = {\n      x: Math.round(Math.max(...eyeBottomArc.map(v => v[0]))),\n      y: Math.round(Math.max(...eyeBottomArc.map(v => v[1])))\n    };\n    return {\n      origin: topLeftOrigin,\n      width: bottomRightOrigin.x - topLeftOrigin.x,\n      height: bottomRightOrigin.y - topLeftOrigin.y\n    };\n  });\n  var leftOriginX = leftBBox.origin.x;\n  var leftOriginY = leftBBox.origin.y;\n  var leftWidth = leftBBox.width;\n  var leftHeight = leftBBox.height;\n  var rightOriginX = rightBBox.origin.x;\n  var rightOriginY = rightBBox.origin.y;\n  var rightWidth = rightBBox.width;\n  var rightHeight = rightBBox.height;\n  if (leftWidth === 0 || rightWidth === 0) {\n    console.log('an eye patch had zero width');\n    return null;\n  }\n  if (leftHeight === 0 || rightHeight === 0) {\n    console.log('an eye patch had zero height');\n    return null;\n  }\n\n  // Start building object to be returned\n  var eyeObjs = {};\n  var leftImageData = imageCanvas.getContext('2d').getImageData(leftOriginX, leftOriginY, leftWidth, leftHeight);\n  eyeObjs.left = {\n    patch: leftImageData,\n    imagex: leftOriginX,\n    imagey: leftOriginY,\n    width: leftWidth,\n    height: leftHeight\n  };\n  var rightImageData = imageCanvas.getContext('2d').getImageData(rightOriginX, rightOriginY, rightWidth, rightHeight);\n  eyeObjs.right = {\n    patch: rightImageData,\n    imagex: rightOriginX,\n    imagey: rightOriginY,\n    width: rightWidth,\n    height: rightHeight\n  };\n  this.predictionReady = true;\n  return eyeObjs;\n};\n\n/**\n * Returns the positions array corresponding to the last call to getEyePatches.\n * Requires that getEyePatches() was called previously, else returns null.\n */\nTFFaceMesh.prototype.getPositions = function () {\n  return this.positionsArray;\n};\n\n/**\n * Reset the tracker to default values\n */\nTFFaceMesh.prototype.reset = function () {\n  console.log(\"Unimplemented; Tracking.js has no obvious reset function\");\n};\n\n/**\n * Draw TF_FaceMesh_Overlay\n */\nTFFaceMesh.prototype.drawFaceOverlay = function (ctx, keypoints) {\n  // If keypoints is falsy, don't do anything\n  if (keypoints) {\n    ctx.fillStyle = '#32EEDB';\n    ctx.strokeStyle = '#32EEDB';\n    ctx.lineWidth = 0.5;\n    for (let i = 0; i < keypoints.length; i++) {\n      const x = keypoints[i][0];\n      const y = keypoints[i][1];\n      ctx.beginPath();\n      ctx.arc(x, y, 1 /* radius */, 0, 2 * Math.PI);\n      ctx.closePath();\n      ctx.fill();\n    }\n  }\n};\n\n/**\n * The TFFaceMesh object name\n * @type {string}\n */\nTFFaceMesh.prototype.name = 'TFFaceMesh';\nexport default TFFaceMesh;","map":{"version":3,"names":["faceLandmarksDetection","TFFaceMesh","model","load","SupportedPackages","mediapipeFacemesh","maxFaces","predictionReady","prototype","positionsArray","getEyePatches","video","imageCanvas","width","height","predictions","estimateFaces","input","returnTensors","flipHorizontal","predictIrises","length","scaledMesh","prediction","positions","leftBBox","rightBBox","eyeTopArc","annotations","leftEyeUpper0","eyeBottomArc","leftEyeLower0","rightEyeUpper0","rightEyeLower0","map","topLeftOrigin","x","Math","round","min","v","y","bottomRightOrigin","max","origin","leftOriginX","leftOriginY","leftWidth","leftHeight","rightOriginX","rightOriginY","rightWidth","rightHeight","console","log","eyeObjs","leftImageData","getContext","getImageData","left","patch","imagex","imagey","rightImageData","right","getPositions","reset","drawFaceOverlay","ctx","keypoints","fillStyle","strokeStyle","lineWidth","i","beginPath","arc","PI","closePath","fill","name"],"sources":["/Users/aqwerrrx/Desktop/special1/frontend/node_modules/webgazer/src/facemesh.mjs"],"sourcesContent":["import * as faceLandmarksDetection from '@tensorflow-models/face-landmarks-detection';\n\n/**\n * Constructor of TFFaceMesh object\n * @constructor\n * */\nconst TFFaceMesh = function() {\n  //Backend options are webgl, wasm, and CPU.\n  //For recent laptops WASM is better than WebGL.\n  this.model = faceLandmarksDetection.load(\n    faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,\n    { maxFaces: 1 }\n  );\n  this.predictionReady = false;\n};\n\n// Global variable for face landmark positions array\nTFFaceMesh.prototype.positionsArray = null;\n\n/**\n * Isolates the two patches that correspond to the user's eyes\n * @param  {Object} video - the video element itself\n * @param  {Canvas} imageCanvas - canvas corresponding to the webcam stream\n * @param  {Number} width - of imageCanvas\n * @param  {Number} height - of imageCanvas\n * @return {Object} the two eye-patches, first left, then right eye\n */\nTFFaceMesh.prototype.getEyePatches = async function(video, imageCanvas, width, height) {\n\n  if (imageCanvas.width === 0) {\n    return null;\n  }\n\n  // Load the MediaPipe facemesh model.\n  const model = await this.model;\n\n  // Pass in a video stream (or an image, canvas, or 3D tensor) to obtain an\n  // array of detected faces from the MediaPipe graph.\n  const predictions = await model.estimateFaces({\n    input: video,\n    returnTensors: false,\n    flipHorizontal: false,\n    predictIrises: false,\n  });\n\n  if (predictions.length == 0){\n    return false;\n  }\n\n  // Save positions to global variable\n  this.positionsArray = predictions[0].scaledMesh;\n  const prediction = predictions[0]\n  const positions = this.positionsArray;\n\n  const { scaledMesh } = predictions[0];\n  // Keypoints indexes are documented at\n  // https://github.com/tensorflow/tfjs-models/blob/118d4727197d4a21e2d4691e134a7bc30d90deee/face-landmarks-detection/mesh_map.jpg\n  // https://stackoverflow.com/questions/66649492/how-to-get-specific-landmark-of-face-like-lips-or-eyes-using-tensorflow-js-face\n  const [leftBBox, rightBBox] = [\n    // left\n    {\n      eyeTopArc: prediction.annotations.leftEyeUpper0,\n      eyeBottomArc: prediction.annotations.leftEyeLower0\n    },\n    // right\n    {\n      eyeTopArc: prediction.annotations.rightEyeUpper0,\n      eyeBottomArc: prediction.annotations.rightEyeLower0\n    },\n  ].map(({ eyeTopArc, eyeBottomArc }) => {\n    const topLeftOrigin = {\n      x: Math.round(Math.min(...eyeTopArc.map(v => v[0]))),\n      y: Math.round(Math.min(...eyeTopArc.map(v => v[1]))),\n    };\n    const bottomRightOrigin = {\n      x: Math.round(Math.max(...eyeBottomArc.map(v => v[0]))),\n      y: Math.round(Math.max(...eyeBottomArc.map(v => v[1]))),\n    };\n\n    return {\n      origin: topLeftOrigin,\n      width: bottomRightOrigin.x - topLeftOrigin.x,\n      height: bottomRightOrigin.y - topLeftOrigin.y,\n    }\n  });\n  var leftOriginX = leftBBox.origin.x;\n  var leftOriginY = leftBBox.origin.y;\n  var leftWidth = leftBBox.width;\n  var leftHeight = leftBBox.height;\n  var rightOriginX = rightBBox.origin.x;\n  var rightOriginY = rightBBox.origin.y;\n  var rightWidth = rightBBox.width;\n  var rightHeight = rightBBox.height;\n\n  if (leftWidth === 0 || rightWidth === 0){\n    console.log('an eye patch had zero width');\n    return null;\n  }\n\n  if (leftHeight === 0 || rightHeight === 0){\n    console.log('an eye patch had zero height');\n    return null;\n  }\n\n  // Start building object to be returned\n  var eyeObjs = {};\n\n  var leftImageData = imageCanvas.getContext('2d').getImageData(leftOriginX, leftOriginY, leftWidth, leftHeight);\n  eyeObjs.left = {\n    patch: leftImageData,\n    imagex: leftOriginX,\n    imagey: leftOriginY,\n    width: leftWidth,\n    height: leftHeight\n  };\n\n  var rightImageData = imageCanvas.getContext('2d').getImageData(rightOriginX, rightOriginY, rightWidth, rightHeight);\n  eyeObjs.right = {\n    patch: rightImageData,\n    imagex: rightOriginX,\n    imagey: rightOriginY,\n    width: rightWidth,\n    height: rightHeight\n  };\n\n  this.predictionReady = true;\n\n  return eyeObjs;\n};\n\n/**\n * Returns the positions array corresponding to the last call to getEyePatches.\n * Requires that getEyePatches() was called previously, else returns null.\n */\nTFFaceMesh.prototype.getPositions = function () {\n  return this.positionsArray;\n}\n\n/**\n * Reset the tracker to default values\n */\nTFFaceMesh.prototype.reset = function(){\n  console.log( \"Unimplemented; Tracking.js has no obvious reset function\" );\n}\n\n/**\n * Draw TF_FaceMesh_Overlay\n */\nTFFaceMesh.prototype.drawFaceOverlay = function(ctx, keypoints){\n  // If keypoints is falsy, don't do anything\n  if (keypoints) {\n    ctx.fillStyle = '#32EEDB';\n    ctx.strokeStyle = '#32EEDB';\n    ctx.lineWidth = 0.5;\n\n    for (let i = 0; i < keypoints.length; i++) {\n      const x = keypoints[i][0];\n      const y = keypoints[i][1];\n\n      ctx.beginPath();\n      ctx.arc(x, y, 1 /* radius */, 0, 2 * Math.PI);\n      ctx.closePath();\n      ctx.fill();\n    }\n  }\n}\n\n/**\n * The TFFaceMesh object name\n * @type {string}\n */\nTFFaceMesh.prototype.name = 'TFFaceMesh';\n\nexport default TFFaceMesh;\n"],"mappings":"AAAA,OAAO,KAAKA,sBAAsB,MAAM,6CAA6C;;AAErF;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAG,SAAAA,CAAA,EAAW;EAC5B;EACA;EACA,IAAI,CAACC,KAAK,GAAGF,sBAAsB,CAACG,IAAI,CACtCH,sBAAsB,CAACI,iBAAiB,CAACC,iBAAiB,EAC1D;IAAEC,QAAQ,EAAE;EAAE,CAChB,CAAC;EACD,IAAI,CAACC,eAAe,GAAG,KAAK;AAC9B,CAAC;;AAED;AACAN,UAAU,CAACO,SAAS,CAACC,cAAc,GAAG,IAAI;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAR,UAAU,CAACO,SAAS,CAACE,aAAa,GAAG,gBAAeC,KAAK,EAAEC,WAAW,EAAEC,KAAK,EAAEC,MAAM,EAAE;EAErF,IAAIF,WAAW,CAACC,KAAK,KAAK,CAAC,EAAE;IAC3B,OAAO,IAAI;EACb;;EAEA;EACA,MAAMX,KAAK,GAAG,MAAM,IAAI,CAACA,KAAK;;EAE9B;EACA;EACA,MAAMa,WAAW,GAAG,MAAMb,KAAK,CAACc,aAAa,CAAC;IAC5CC,KAAK,EAAEN,KAAK;IACZO,aAAa,EAAE,KAAK;IACpBC,cAAc,EAAE,KAAK;IACrBC,aAAa,EAAE;EACjB,CAAC,CAAC;EAEF,IAAIL,WAAW,CAACM,MAAM,IAAI,CAAC,EAAC;IAC1B,OAAO,KAAK;EACd;;EAEA;EACA,IAAI,CAACZ,cAAc,GAAGM,WAAW,CAAC,CAAC,CAAC,CAACO,UAAU;EAC/C,MAAMC,UAAU,GAAGR,WAAW,CAAC,CAAC,CAAC;EACjC,MAAMS,SAAS,GAAG,IAAI,CAACf,cAAc;EAErC,MAAM;IAAEa;EAAW,CAAC,GAAGP,WAAW,CAAC,CAAC,CAAC;EACrC;EACA;EACA;EACA,MAAM,CAACU,QAAQ,EAAEC,SAAS,CAAC,GAAG;EAC5B;EACA;IACEC,SAAS,EAAEJ,UAAU,CAACK,WAAW,CAACC,aAAa;IAC/CC,YAAY,EAAEP,UAAU,CAACK,WAAW,CAACG;EACvC,CAAC;EACD;EACA;IACEJ,SAAS,EAAEJ,UAAU,CAACK,WAAW,CAACI,cAAc;IAChDF,YAAY,EAAEP,UAAU,CAACK,WAAW,CAACK;EACvC,CAAC,CACF,CAACC,GAAG,CAAC,CAAC;IAAEP,SAAS;IAAEG;EAAa,CAAC,KAAK;IACrC,MAAMK,aAAa,GAAG;MACpBC,CAAC,EAAEC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,GAAG,CAAC,GAAGZ,SAAS,CAACO,GAAG,CAACM,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACpDC,CAAC,EAAEJ,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,GAAG,CAAC,GAAGZ,SAAS,CAACO,GAAG,CAACM,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACrD,CAAC;IACD,MAAME,iBAAiB,GAAG;MACxBN,CAAC,EAAEC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACM,GAAG,CAAC,GAAGb,YAAY,CAACI,GAAG,CAACM,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACvDC,CAAC,EAAEJ,IAAI,CAACC,KAAK,CAACD,IAAI,CAACM,GAAG,CAAC,GAAGb,YAAY,CAACI,GAAG,CAACM,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACxD,CAAC;IAED,OAAO;MACLI,MAAM,EAAET,aAAa;MACrBtB,KAAK,EAAE6B,iBAAiB,CAACN,CAAC,GAAGD,aAAa,CAACC,CAAC;MAC5CtB,MAAM,EAAE4B,iBAAiB,CAACD,CAAC,GAAGN,aAAa,CAACM;IAC9C,CAAC;EACH,CAAC,CAAC;EACF,IAAII,WAAW,GAAGpB,QAAQ,CAACmB,MAAM,CAACR,CAAC;EACnC,IAAIU,WAAW,GAAGrB,QAAQ,CAACmB,MAAM,CAACH,CAAC;EACnC,IAAIM,SAAS,GAAGtB,QAAQ,CAACZ,KAAK;EAC9B,IAAImC,UAAU,GAAGvB,QAAQ,CAACX,MAAM;EAChC,IAAImC,YAAY,GAAGvB,SAAS,CAACkB,MAAM,CAACR,CAAC;EACrC,IAAIc,YAAY,GAAGxB,SAAS,CAACkB,MAAM,CAACH,CAAC;EACrC,IAAIU,UAAU,GAAGzB,SAAS,CAACb,KAAK;EAChC,IAAIuC,WAAW,GAAG1B,SAAS,CAACZ,MAAM;EAElC,IAAIiC,SAAS,KAAK,CAAC,IAAII,UAAU,KAAK,CAAC,EAAC;IACtCE,OAAO,CAACC,GAAG,CAAC,6BAA6B,CAAC;IAC1C,OAAO,IAAI;EACb;EAEA,IAAIN,UAAU,KAAK,CAAC,IAAII,WAAW,KAAK,CAAC,EAAC;IACxCC,OAAO,CAACC,GAAG,CAAC,8BAA8B,CAAC;IAC3C,OAAO,IAAI;EACb;;EAEA;EACA,IAAIC,OAAO,GAAG,CAAC,CAAC;EAEhB,IAAIC,aAAa,GAAG5C,WAAW,CAAC6C,UAAU,CAAC,IAAI,CAAC,CAACC,YAAY,CAACb,WAAW,EAAEC,WAAW,EAAEC,SAAS,EAAEC,UAAU,CAAC;EAC9GO,OAAO,CAACI,IAAI,GAAG;IACbC,KAAK,EAAEJ,aAAa;IACpBK,MAAM,EAAEhB,WAAW;IACnBiB,MAAM,EAAEhB,WAAW;IACnBjC,KAAK,EAAEkC,SAAS;IAChBjC,MAAM,EAAEkC;EACV,CAAC;EAED,IAAIe,cAAc,GAAGnD,WAAW,CAAC6C,UAAU,CAAC,IAAI,CAAC,CAACC,YAAY,CAACT,YAAY,EAAEC,YAAY,EAAEC,UAAU,EAAEC,WAAW,CAAC;EACnHG,OAAO,CAACS,KAAK,GAAG;IACdJ,KAAK,EAAEG,cAAc;IACrBF,MAAM,EAAEZ,YAAY;IACpBa,MAAM,EAAEZ,YAAY;IACpBrC,KAAK,EAAEsC,UAAU;IACjBrC,MAAM,EAAEsC;EACV,CAAC;EAED,IAAI,CAAC7C,eAAe,GAAG,IAAI;EAE3B,OAAOgD,OAAO;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACAtD,UAAU,CAACO,SAAS,CAACyD,YAAY,GAAG,YAAY;EAC9C,OAAO,IAAI,CAACxD,cAAc;AAC5B,CAAC;;AAED;AACA;AACA;AACAR,UAAU,CAACO,SAAS,CAAC0D,KAAK,GAAG,YAAU;EACrCb,OAAO,CAACC,GAAG,CAAE,0DAA2D,CAAC;AAC3E,CAAC;;AAED;AACA;AACA;AACArD,UAAU,CAACO,SAAS,CAAC2D,eAAe,GAAG,UAASC,GAAG,EAAEC,SAAS,EAAC;EAC7D;EACA,IAAIA,SAAS,EAAE;IACbD,GAAG,CAACE,SAAS,GAAG,SAAS;IACzBF,GAAG,CAACG,WAAW,GAAG,SAAS;IAC3BH,GAAG,CAACI,SAAS,GAAG,GAAG;IAEnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,SAAS,CAAChD,MAAM,EAAEoD,CAAC,EAAE,EAAE;MACzC,MAAMrC,CAAC,GAAGiC,SAAS,CAACI,CAAC,CAAC,CAAC,CAAC,CAAC;MACzB,MAAMhC,CAAC,GAAG4B,SAAS,CAACI,CAAC,CAAC,CAAC,CAAC,CAAC;MAEzBL,GAAG,CAACM,SAAS,CAAC,CAAC;MACfN,GAAG,CAACO,GAAG,CAACvC,CAAC,EAAEK,CAAC,EAAE,CAAC,CAAC,cAAc,CAAC,EAAE,CAAC,GAAGJ,IAAI,CAACuC,EAAE,CAAC;MAC7CR,GAAG,CAACS,SAAS,CAAC,CAAC;MACfT,GAAG,CAACU,IAAI,CAAC,CAAC;IACZ;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA7E,UAAU,CAACO,SAAS,CAACuE,IAAI,GAAG,YAAY;AAExC,eAAe9E,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}