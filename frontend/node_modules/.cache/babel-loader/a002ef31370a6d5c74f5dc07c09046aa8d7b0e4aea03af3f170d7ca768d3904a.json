{"ast":null,"code":"import util from './util.mjs';\nimport util_regression from './util_regression.mjs';\nimport params from './params.mjs';\nconst reg = {};\n\n/**\n * Constructor of RidgeReg object,\n * this object allow to perform ridge regression\n * @constructor\n */\nreg.RidgeReg = function () {\n  this.init();\n};\n\n/**\n * Initialize new arrays and initialize Kalman filter.\n */\nreg.RidgeReg.prototype.init = util_regression.InitRegression;\n\n/**\n * Add given data from eyes\n * @param {Object} eyes - eyes where extract data to add\n * @param {Object} screenPos - The current screen point\n * @param {Object} type - The type of performed action\n */\nreg.RidgeReg.prototype.addData = util_regression.addData;\n\n/**\n * Try to predict coordinates from pupil data\n * after apply linear regression on data set\n * @param {Object} eyesObj - The current user eyes object\n * @returns {Object}\n */\nreg.RidgeReg.prototype.predict = function (eyesObj) {\n  if (!eyesObj || this.eyeFeaturesClicks.length === 0) {\n    return null;\n  }\n  var acceptTime = performance.now() - this.trailTime;\n  var trailX = [];\n  var trailY = [];\n  var trailFeat = [];\n  for (var i = 0; i < this.trailDataWindow; i++) {\n    if (this.trailTimes.get(i) > acceptTime) {\n      trailX.push(this.screenXTrailArray.get(i));\n      trailY.push(this.screenYTrailArray.get(i));\n      trailFeat.push(this.eyeFeaturesTrail.get(i));\n    }\n  }\n  var screenXArray = this.screenXClicksArray.data.concat(trailX);\n  var screenYArray = this.screenYClicksArray.data.concat(trailY);\n  var eyeFeatures = this.eyeFeaturesClicks.data.concat(trailFeat);\n  var coefficientsX = util_regression.ridge(screenXArray, eyeFeatures, this.ridgeParameter);\n  var coefficientsY = util_regression.ridge(screenYArray, eyeFeatures, this.ridgeParameter);\n  var eyeFeats = util.getEyeFeats(eyesObj);\n  var predictedX = 0;\n  for (var i = 0; i < eyeFeats.length; i++) {\n    predictedX += eyeFeats[i] * coefficientsX[i];\n  }\n  var predictedY = 0;\n  for (var i = 0; i < eyeFeats.length; i++) {\n    predictedY += eyeFeats[i] * coefficientsY[i];\n  }\n  predictedX = Math.floor(predictedX);\n  predictedY = Math.floor(predictedY);\n  if (params.applyKalmanFilter) {\n    // Update Kalman model, and get prediction\n    var newGaze = [predictedX, predictedY]; // [20200607 xk] Should we use a 1x4 vector?\n    newGaze = this.kalman.update(newGaze);\n    return {\n      x: newGaze[0],\n      y: newGaze[1]\n    };\n  } else {\n    return {\n      x: predictedX,\n      y: predictedY\n    };\n  }\n};\nreg.RidgeReg.prototype.setData = util_regression.setData;\n\n/**\n * Return the data\n * @returns {Array.<Object>|*}\n */\nreg.RidgeReg.prototype.getData = function () {\n  return this.dataClicks.data;\n};\n\n/**\n * The RidgeReg object name\n * @type {string}\n */\nreg.RidgeReg.prototype.name = 'ridge';\nexport default reg;","map":{"version":3,"names":["util","util_regression","params","reg","RidgeReg","init","prototype","InitRegression","addData","predict","eyesObj","eyeFeaturesClicks","length","acceptTime","performance","now","trailTime","trailX","trailY","trailFeat","i","trailDataWindow","trailTimes","get","push","screenXTrailArray","screenYTrailArray","eyeFeaturesTrail","screenXArray","screenXClicksArray","data","concat","screenYArray","screenYClicksArray","eyeFeatures","coefficientsX","ridge","ridgeParameter","coefficientsY","eyeFeats","getEyeFeats","predictedX","predictedY","Math","floor","applyKalmanFilter","newGaze","kalman","update","x","y","setData","getData","dataClicks","name"],"sources":["/Users/aqwerrrx/Desktop/special1/frontend/node_modules/webgazer/src/ridgeReg.mjs"],"sourcesContent":["import util from './util.mjs';\nimport util_regression from './util_regression.mjs';\nimport params from './params.mjs';\n\nconst reg = {};\n\n/**\n * Constructor of RidgeReg object,\n * this object allow to perform ridge regression\n * @constructor\n */\nreg.RidgeReg = function() {\n  this.init();\n};\n\n/**\n * Initialize new arrays and initialize Kalman filter.\n */\nreg.RidgeReg.prototype.init = util_regression.InitRegression\n\n/**\n * Add given data from eyes\n * @param {Object} eyes - eyes where extract data to add\n * @param {Object} screenPos - The current screen point\n * @param {Object} type - The type of performed action\n */\nreg.RidgeReg.prototype.addData = util_regression.addData\n\n/**\n * Try to predict coordinates from pupil data\n * after apply linear regression on data set\n * @param {Object} eyesObj - The current user eyes object\n * @returns {Object}\n */\nreg.RidgeReg.prototype.predict = function(eyesObj) {\n  if (!eyesObj || this.eyeFeaturesClicks.length === 0) {\n    return null;\n  }\n  var acceptTime = performance.now() - this.trailTime;\n  var trailX = [];\n  var trailY = [];\n  var trailFeat = [];\n  for (var i = 0; i < this.trailDataWindow; i++) {\n    if (this.trailTimes.get(i) > acceptTime) {\n      trailX.push(this.screenXTrailArray.get(i));\n      trailY.push(this.screenYTrailArray.get(i));\n      trailFeat.push(this.eyeFeaturesTrail.get(i));\n    }\n  }\n\n  var screenXArray = this.screenXClicksArray.data.concat(trailX);\n  var screenYArray = this.screenYClicksArray.data.concat(trailY);\n  var eyeFeatures = this.eyeFeaturesClicks.data.concat(trailFeat);\n\n  var coefficientsX = util_regression.ridge(screenXArray, eyeFeatures, this.ridgeParameter);\n  var coefficientsY = util_regression.ridge(screenYArray, eyeFeatures, this.ridgeParameter);\n\n  var eyeFeats = util.getEyeFeats(eyesObj);\n  var predictedX = 0;\n  for(var i=0; i< eyeFeats.length; i++){\n    predictedX += eyeFeats[i] * coefficientsX[i];\n  }\n  var predictedY = 0;\n  for(var i=0; i< eyeFeats.length; i++){\n    predictedY += eyeFeats[i] * coefficientsY[i];\n  }\n\n  predictedX = Math.floor(predictedX);\n  predictedY = Math.floor(predictedY);\n\n  if (params.applyKalmanFilter) {\n    // Update Kalman model, and get prediction\n    var newGaze = [predictedX, predictedY]; // [20200607 xk] Should we use a 1x4 vector?\n    newGaze = this.kalman.update(newGaze);\n\n    return {\n      x: newGaze[0],\n      y: newGaze[1]\n    };\n  } else {\n    return {\n      x: predictedX,\n      y: predictedY\n    };\n  }\n};\n\nreg.RidgeReg.prototype.setData = util_regression.setData;\n\n/**\n * Return the data\n * @returns {Array.<Object>|*}\n */\nreg.RidgeReg.prototype.getData = function() {\n  return this.dataClicks.data;\n}\n\n/**\n * The RidgeReg object name\n * @type {string}\n */\nreg.RidgeReg.prototype.name = 'ridge';\n\nexport default reg;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}