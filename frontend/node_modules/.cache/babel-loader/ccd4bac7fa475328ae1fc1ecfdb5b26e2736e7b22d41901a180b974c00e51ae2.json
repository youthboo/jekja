{"ast":null,"code":"/**\n * Matrix operations, mostly based on WEKA\n * @see https://github.com/Waikato/weka-3.8/blob/master/weka/src/main/java/weka/core/matrix/Matrix.java\n */\n\n/**\n * @callback operationCallback\n * @param {number} a - an element of matrix A\n * @param {number} b - an element of matrix B\n * @return {number} a ○ b\n */\n/**\n * Apply arithmetic operations to every element of A and B:\n * X = A ○ B, where ○ can be one of +, -, *, /, etc.\n *\n * @param {Array.<Array.<Number>>} A\n * @param {Array.<Array.<Number>>} B\n * @param {operationCallback} op - operation to apply, op(a, b) => a ○ b\n * @return {Array.<Array.<Number>>} A ○ B\n */\nfunction applyArithmeticOperation(A, B, op) {\n  if (A.length !== B.length || A[0].length !== B[0].length) {\n    throw new Error('Matrix dimensions must agree.');\n  }\n  const rows = A.length;\n  const cols = A[0].length;\n  const X = new Array(rows);\n  for (let i = 0; i < rows; i++) {\n    X[i] = new Array(cols);\n    for (let j = 0; j < cols; j++) {\n      X[i][j] = op(A[i][j], B[i][j]);\n    }\n  }\n  return X;\n}\nconst mat = {\n  /**\n   * Transposes an m*n array\n   * @param {Array.<Array.<Number>>} matrix - of 'M x N' dimensionality\n   * @return {Array.<Array.<Number>>} transposed matrix\n   */\n  transpose(matrix) {\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    const transposedMatrix = new Array(cols);\n    for (let j = 0; j < cols; j++) {\n      transposedMatrix[j] = new Array(rows);\n      for (let i = 0; i < rows; i++) {\n        transposedMatrix[j][i] = matrix[i][j];\n      }\n    }\n    return transposedMatrix;\n  },\n  /**\n   * Get a sub-matrix of matrix\n   * @param {Array.<Array.<Number>>} matrix - original matrix\n   * @param {Array.<Number>} r - Array of row indices\n   * @param {Number} j0 - Initial column index\n   * @param {Number} j1 - Final column index\n   * @returns {Array} The sub-matrix matrix(r(:),j0:j1)\n   */\n  getMatrix(matrix, r, j0, j1) {\n    const X = new Array(r.length);\n    const m = j1 - j0 + 1;\n    for (let i = 0, len = r.length; i < len; i++) {\n      X[i] = new Array(m);\n      for (let j = j0; j <= j1; j++) {\n        X[i][j - j0] = matrix[r[i]][j];\n      }\n    }\n    return X;\n  },\n  /**\n   * Get a submatrix of matrix\n   * @param {Array.<Array.<Number>>} matrix - original matrix\n   * @param {Number} i0 - Initial row index\n   * @param {Number} i1 - Final row index\n   * @param {Number} j0 - Initial column index\n   * @param {Number} j1 - Final column index\n   * @return {Array} The sub-matrix matrix(i0:i1,j0:j1)\n   */\n  getSubMatrix(matrix, i0, i1, j0, j1) {\n    const size = j1 - j0 + 1;\n    const X = new Array(i1 - i0 + 1);\n    for (let i = i0; i <= i1; i++) {\n      const subI = i - i0;\n      X[subI] = new Array(size);\n      for (let j = j0; j <= j1; j++) {\n        X[subI][j - j0] = matrix[i][j];\n      }\n    }\n    return X;\n  },\n  /**\n   * Linear algebraic matrix multiplication, X = A * B\n   * @param {Array.<Array.<Number>>} A\n   * @param {Array.<Array.<Number>>} B\n   * @return {Array.<Array.<Number>>} Matrix product, A * B\n   */\n  mult(matrix1, matrix2) {\n    if (matrix2.length != matrix1[0].length) {\n      console.log('Matrix inner dimensions must agree:');\n    }\n    var X = new Array(matrix1.length),\n      Bcolj = new Array(matrix1[0].length);\n    for (var j = 0; j < matrix2[0].length; j++) {\n      for (var k = 0; k < matrix1[0].length; k++) {\n        Bcolj[k] = matrix2[k][j];\n      }\n      for (var i = 0; i < matrix1.length; i++) {\n        if (j === 0) X[i] = new Array(matrix2[0].length);\n        var Arowi = matrix1[i];\n        var s = 0;\n        for (var k = 0; k < matrix1[0].length; k++) {\n          s += Arowi[k] * Bcolj[k];\n        }\n        X[i][j] = s;\n      }\n    }\n    return X;\n  },\n  /**\n   * Multiply a matrix by a scalar, X = s*A\n   * @param {Array.<Array.<Number>>}  A - matrix\n   * @param {Number}                  s - scalar\n   * @return {Array.<Array.<Number>>} s*A\n   */\n  multScalar(A, s) {\n    const rows = A.length;\n    const cols = A[0].length;\n    const X = new Array(rows);\n    for (let i = 0; i < rows; i++) {\n      X[i] = new Array(cols);\n      for (let j = 0; j < cols; j++) {\n        X[i][j] = A[i][j] * s;\n      }\n    }\n    return X;\n  },\n  /**\n   * Linear algebraic matrix addition, X = A + B\n   * @param {Array.<Array.<Number>>} A\n   * @param {Array.<Array.<Number>>} B\n   * @return {Array.<Array.<Number>>} A + B\n   */\n  add(A, B) {\n    return applyArithmeticOperation(A, B, (a, b) => a + b);\n  },\n  /**\n   * Linear algebraic matrix subtraction, X = A - B\n   * @param {Array.<Array.<Number>>} A\n   * @param {Array.<Array.<Number>>} B\n   * @return {Array.<Array.<Number>>} A - B\n   */\n  sub(A, B) {\n    return applyArithmeticOperation(A, B, (a, b) => a - b);\n  },\n  /**\n   * Matrix inverse or pseudoinverse, based on WEKA code\n   * @param {Array.<Array.<Number>>} A - original matrix\n   * @return inverse(A) if A is square, pseudoinverse otherwise.\n   */\n  inv(A) {\n    return mat.solve(A, mat.identity(A.length, A[0].length));\n  },\n  /**\n   * Generate identity matrix, based on WEKA code\n   * @param {Number} m - number of rows.\n   * @param {Number} [n] - number of colums, n = m if undefined.\n   * @return {Array.<Array.<Number>>} An m * n matrix with ones on the diagonal and zeros elsewhere.\n   */\n  identity(m, n = m) {\n    const X = new Array(m);\n    for (let i = 0; i < m; i++) {\n      X[i] = new Array(n);\n      for (let j = 0; j < n; j++) {\n        X[i][j] = i === j ? 1.0 : 0.0;\n      }\n    }\n    return X;\n  },\n  /**\n   * Solve A*X = B, based on WEKA code\n   * @param {Array.<Array.<Number>>} A - left matrix of equation to be solved\n   * @param {Array.<Array.<Number>>} B - right matrix of equation to be solved\n   * @return {Array.<Array.<Number>>}  solution if A is square, least squares solution otherwiseis\n   */\n  solve(A, B) {\n    if (A.length === A[0].length) {\n      // A is square\n      return mat.LUDecomposition(A, B);\n    }\n    return mat.QRDecomposition(A, B);\n  },\n  /**\n   * LUDecomposition to solve A*X = B, based on WEKA code\n   * @param {Array.<Array.<Number>>} A - left matrix of equation to be solved\n   * @param {Array.<Array.<Number>>} B - right matrix of equation to be solved\n   * @return {Array.<Array.<Number>>} X so that L*U*X = B(piv,:)\n   */\n  LUDecomposition(A, B) {\n    var LU = new Array(A.length);\n    for (var i = 0; i < A.length; i++) {\n      LU[i] = new Array(A[0].length);\n      for (var j = 0; j < A[0].length; j++) {\n        LU[i][j] = A[i][j];\n      }\n    }\n    var m = A.length;\n    var n = A[0].length;\n    var piv = new Array(m);\n    for (var i = 0; i < m; i++) {\n      piv[i] = i;\n    }\n    var pivsign = 1;\n    var LUrowi = new Array();\n    var LUcolj = new Array(m);\n    // Outer loop.\n    for (var j = 0; j < n; j++) {\n      // Make a copy of the j-th column to localize references.\n      for (var i = 0; i < m; i++) {\n        LUcolj[i] = LU[i][j];\n      }\n      // Apply previous transformations.\n      for (var i = 0; i < m; i++) {\n        LUrowi = LU[i];\n        // Most of the time is spent in the following dot product.\n        var kmax = Math.min(i, j);\n        var s = 0;\n        for (var k = 0; k < kmax; k++) {\n          s += LUrowi[k] * LUcolj[k];\n        }\n        LUrowi[j] = LUcolj[i] -= s;\n      }\n      // Find pivot and exchange if necessary.\n      var p = j;\n      for (var i = j + 1; i < m; i++) {\n        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n          p = i;\n        }\n      }\n      if (p != j) {\n        for (var k = 0; k < n; k++) {\n          var t = LU[p][k];\n          LU[p][k] = LU[j][k];\n          LU[j][k] = t;\n        }\n        var k = piv[p];\n        piv[p] = piv[j];\n        piv[j] = k;\n        pivsign = -pivsign;\n      }\n      // Compute multipliers.\n      if (j < m & LU[j][j] != 0) {\n        for (var i = j + 1; i < m; i++) {\n          LU[i][j] /= LU[j][j];\n        }\n      }\n    }\n    if (B.length != m) {\n      console.log('Matrix row dimensions must agree.');\n    }\n    for (var j = 0; j < n; j++) {\n      if (LU[j][j] === 0) {\n        console.log('Matrix is singular.');\n      }\n    }\n    var nx = B[0].length;\n    var X = mat.getMatrix(B, piv, 0, nx - 1);\n    // Solve L*Y = B(piv,:)\n    for (var k = 0; k < n; k++) {\n      for (var i = k + 1; i < n; i++) {\n        for (var j = 0; j < nx; j++) {\n          X[i][j] -= X[k][j] * LU[i][k];\n        }\n      }\n    }\n    // Solve U*X = Y;\n    for (var k = n - 1; k >= 0; k--) {\n      for (var j = 0; j < nx; j++) {\n        X[k][j] /= LU[k][k];\n      }\n      for (var i = 0; i < k; i++) {\n        for (var j = 0; j < nx; j++) {\n          X[i][j] -= X[k][j] * LU[i][k];\n        }\n      }\n    }\n    return X;\n  },\n  /**\n   * Least squares solution of A*X = B, based on WEKA code\n   * @param {Array.<Array.<Number>>} A - left side matrix to be solved\n   * @param {Array.<Array.<Number>>} B - a matrix with as many rows as A and any number of columns.\n   * @return {Array.<Array.<Number>>} X - that minimizes the two norms of QR*X-B.\n   */\n  QRDecomposition(A, B) {\n    // Initialize.\n    var QR = new Array(A.length);\n    for (var i = 0; i < A.length; i++) {\n      QR[i] = new Array(A[0].length);\n      for (var j = 0; j < A[0].length; j++) {\n        QR[i][j] = A[i][j];\n      }\n    }\n    var m = A.length;\n    var n = A[0].length;\n    var Rdiag = new Array(n);\n    var nrm;\n\n    // Main loop.\n    for (var k = 0; k < n; k++) {\n      // Compute 2-norm of k-th column without under/overflow.\n      nrm = 0;\n      for (var i = k; i < m; i++) {\n        nrm = Math.hypot(nrm, QR[i][k]);\n      }\n      if (nrm != 0) {\n        // Form k-th Householder vector.\n        if (QR[k][k] < 0) {\n          nrm = -nrm;\n        }\n        for (var i = k; i < m; i++) {\n          QR[i][k] /= nrm;\n        }\n        QR[k][k] += 1;\n\n        // Apply transformation to remaining columns.\n        for (var j = k + 1; j < n; j++) {\n          var s = 0;\n          for (var i = k; i < m; i++) {\n            s += QR[i][k] * QR[i][j];\n          }\n          s = -s / QR[k][k];\n          for (var i = k; i < m; i++) {\n            QR[i][j] += s * QR[i][k];\n          }\n        }\n      }\n      Rdiag[k] = -nrm;\n    }\n    if (B.length != m) {\n      console.log('Matrix row dimensions must agree.');\n    }\n    for (var j = 0; j < n; j++) {\n      if (Rdiag[j] === 0) console.log('Matrix is rank deficient');\n    }\n    // Copy right hand side\n    var nx = B[0].length;\n    var X = new Array(B.length);\n    for (var i = 0; i < B.length; i++) {\n      X[i] = new Array(B[0].length);\n    }\n    for (var i = 0; i < B.length; i++) {\n      for (var j = 0; j < B[0].length; j++) {\n        X[i][j] = B[i][j];\n      }\n    }\n    // Compute Y = transpose(Q)*B\n    for (var k = 0; k < n; k++) {\n      for (var j = 0; j < nx; j++) {\n        var s = 0.0;\n        for (var i = k; i < m; i++) {\n          s += QR[i][k] * X[i][j];\n        }\n        s = -s / QR[k][k];\n        for (var i = k; i < m; i++) {\n          X[i][j] += s * QR[i][k];\n        }\n      }\n    }\n    // Solve R*X = Y;\n    for (var k = n - 1; k >= 0; k--) {\n      for (var j = 0; j < nx; j++) {\n        X[k][j] /= Rdiag[k];\n      }\n      for (var i = 0; i < k; i++) {\n        for (var j = 0; j < nx; j++) {\n          X[i][j] -= X[k][j] * QR[i][k];\n        }\n      }\n    }\n    return mat.getSubMatrix(X, 0, n - 1, 0, nx - 1);\n  }\n};\nexport default mat;","map":{"version":3,"names":["applyArithmeticOperation","A","B","op","length","Error","rows","cols","X","Array","i","j","mat","transpose","matrix","transposedMatrix","getMatrix","r","j0","j1","m","len","getSubMatrix","i0","i1","size","subI","mult","matrix1","matrix2","console","log","Bcolj","k","Arowi","s","multScalar","add","a","b","sub","inv","solve","identity","n","LUDecomposition","QRDecomposition","LU","piv","pivsign","LUrowi","LUcolj","kmax","Math","min","p","abs","t","nx","QR","Rdiag","nrm","hypot"],"sources":["/Users/aqwerrrx/Desktop/special1/frontend/node_modules/webgazer/src/mat.mjs"],"sourcesContent":["/**\n * Matrix operations, mostly based on WEKA\n * @see https://github.com/Waikato/weka-3.8/blob/master/weka/src/main/java/weka/core/matrix/Matrix.java\n */\n\n/**\n * @callback operationCallback\n * @param {number} a - an element of matrix A\n * @param {number} b - an element of matrix B\n * @return {number} a ○ b\n */\n/**\n * Apply arithmetic operations to every element of A and B:\n * X = A ○ B, where ○ can be one of +, -, *, /, etc.\n *\n * @param {Array.<Array.<Number>>} A\n * @param {Array.<Array.<Number>>} B\n * @param {operationCallback} op - operation to apply, op(a, b) => a ○ b\n * @return {Array.<Array.<Number>>} A ○ B\n */\nfunction applyArithmeticOperation(A, B, op) {\n\n    if (A.length !== B.length || A[0].length !== B[0].length) {\n        throw new Error('Matrix dimensions must agree.');\n    }\n\n    const rows = A.length;\n    const cols = A[0].length;\n\n    const X = new Array(rows);\n\n    for (let i = 0; i < rows; i++) {\n        X[i] = new Array(cols);\n\n        for (let j = 0; j < cols; j++) {\n            X[i][j] = op(A[i][j], B[i][j]);\n        }\n    }\n\n    return X;\n}\n\nconst mat = {\n    /**\n     * Transposes an m*n array\n     * @param {Array.<Array.<Number>>} matrix - of 'M x N' dimensionality\n     * @return {Array.<Array.<Number>>} transposed matrix\n     */\n    transpose(matrix) {\n        const rows = matrix.length;\n        const cols = matrix[0].length;\n        const transposedMatrix = new Array(cols);\n\n        for (let j = 0; j < cols; j++) {\n            transposedMatrix[j] = new Array(rows);\n\n            for (let i = 0; i < rows; i++) {\n                transposedMatrix[j][i] = matrix[i][j];\n            }\n        }\n\n        return transposedMatrix;\n    },\n\n    /**\n     * Get a sub-matrix of matrix\n     * @param {Array.<Array.<Number>>} matrix - original matrix\n     * @param {Array.<Number>} r - Array of row indices\n     * @param {Number} j0 - Initial column index\n     * @param {Number} j1 - Final column index\n     * @returns {Array} The sub-matrix matrix(r(:),j0:j1)\n     */\n    getMatrix(matrix, r, j0, j1) {\n        const X = new Array(r.length);\n        const m = j1 - j0 + 1;\n\n        for (let i = 0, len = r.length; i < len; i++) {\n            X[i] = new Array(m);\n\n            for (let j = j0; j <= j1; j++) {\n                X[i][j - j0] = matrix[r[i]][j];\n            }\n        }\n\n        return X;\n    },\n\n    /**\n     * Get a submatrix of matrix\n     * @param {Array.<Array.<Number>>} matrix - original matrix\n     * @param {Number} i0 - Initial row index\n     * @param {Number} i1 - Final row index\n     * @param {Number} j0 - Initial column index\n     * @param {Number} j1 - Final column index\n     * @return {Array} The sub-matrix matrix(i0:i1,j0:j1)\n     */\n    getSubMatrix(matrix, i0, i1, j0, j1) {\n        const size = j1 - j0 + 1;\n        const X = new Array(i1 - i0 + 1);\n\n        for (let i = i0; i <= i1; i++) {\n            const subI = i - i0;\n            X[subI] = new Array(size);\n\n            for (let j = j0; j <= j1; j++) {\n                X[subI][j - j0] = matrix[i][j];\n            }\n        }\n\n        return X;\n    },\n\n    /**\n     * Linear algebraic matrix multiplication, X = A * B\n     * @param {Array.<Array.<Number>>} A\n     * @param {Array.<Array.<Number>>} B\n     * @return {Array.<Array.<Number>>} Matrix product, A * B\n     */\n    mult(matrix1, matrix2) {\n        if (matrix2.length != matrix1[0].length){\n            console.log('Matrix inner dimensions must agree:');\n        }\n\n        var X = new Array(matrix1.length),\n            Bcolj = new Array(matrix1[0].length);\n\n        for (var j = 0; j < matrix2[0].length; j++){\n            for (var k = 0; k < matrix1[0].length; k++){\n                Bcolj[k] = matrix2[k][j];\n            }\n            for (var i = 0; i < matrix1.length; i++){\n\n                if (j === 0)\n                    X[i] = new Array(matrix2[0].length);\n\n                var Arowi = matrix1[i];\n                var s = 0;\n                for (var k = 0; k < matrix1[0].length; k++){\n                    s += Arowi[k]*Bcolj[k];\n                }\n                X[i][j] = s;\n            }\n        }\n        return X;\n    },\n\n    /**\n     * Multiply a matrix by a scalar, X = s*A\n     * @param {Array.<Array.<Number>>}  A - matrix\n     * @param {Number}                  s - scalar\n     * @return {Array.<Array.<Number>>} s*A\n     */\n    multScalar(A, s) {\n        const rows = A.length;\n        const cols = A[0].length;\n\n        const X = new Array(rows);\n\n        for (let i = 0; i < rows; i++) {\n            X[i] = new Array(cols);\n\n            for (let j = 0; j < cols; j++) {\n                X[i][j] = A[i][j] * s;\n            }\n        }\n\n        return X;\n    },\n\n    /**\n     * Linear algebraic matrix addition, X = A + B\n     * @param {Array.<Array.<Number>>} A\n     * @param {Array.<Array.<Number>>} B\n     * @return {Array.<Array.<Number>>} A + B\n     */\n    add(A, B) {\n        return applyArithmeticOperation(A, B, (a, b) => a + b);\n    },\n\n    /**\n     * Linear algebraic matrix subtraction, X = A - B\n     * @param {Array.<Array.<Number>>} A\n     * @param {Array.<Array.<Number>>} B\n     * @return {Array.<Array.<Number>>} A - B\n     */\n    sub(A, B) {\n        return applyArithmeticOperation(A, B, (a, b) => a - b);\n    },\n\n    /**\n     * Matrix inverse or pseudoinverse, based on WEKA code\n     * @param {Array.<Array.<Number>>} A - original matrix\n     * @return inverse(A) if A is square, pseudoinverse otherwise.\n     */\n    inv(A) {\n        return mat.solve(A, mat.identity(A.length, A[0].length));\n    },\n\n    /**\n     * Generate identity matrix, based on WEKA code\n     * @param {Number} m - number of rows.\n     * @param {Number} [n] - number of colums, n = m if undefined.\n     * @return {Array.<Array.<Number>>} An m * n matrix with ones on the diagonal and zeros elsewhere.\n     */\n    identity(m, n = m) {\n        const X = new Array(m);\n\n        for (let i = 0; i < m; i++) {\n            X[i] = new Array(n);\n\n            for (let j = 0; j < n; j++) {\n                X[i][j] = (i === j ? 1.0 : 0.0);\n            }\n        }\n\n        return X;\n    },\n\n    /**\n     * Solve A*X = B, based on WEKA code\n     * @param {Array.<Array.<Number>>} A - left matrix of equation to be solved\n     * @param {Array.<Array.<Number>>} B - right matrix of equation to be solved\n     * @return {Array.<Array.<Number>>}  solution if A is square, least squares solution otherwiseis\n     */\n    solve(A, B) {\n        if (A.length === A[0].length) {\n            // A is square\n            return mat.LUDecomposition(A, B);\n        }\n\n        return mat.QRDecomposition(A, B);\n    },\n\n    /**\n     * LUDecomposition to solve A*X = B, based on WEKA code\n     * @param {Array.<Array.<Number>>} A - left matrix of equation to be solved\n     * @param {Array.<Array.<Number>>} B - right matrix of equation to be solved\n     * @return {Array.<Array.<Number>>} X so that L*U*X = B(piv,:)\n     */\n    LUDecomposition(A, B) {\n        var LU = new Array(A.length);\n\n        for (var i = 0; i < A.length; i++){\n            LU[i] = new Array(A[0].length);\n            for (var j = 0; j < A[0].length; j++){\n                LU[i][j] = A[i][j];\n            }\n        }\n\n        var m = A.length;\n        var n = A[0].length;\n        var piv = new Array(m);\n        for (var i = 0; i < m; i++){\n            piv[i] = i;\n        }\n        var pivsign = 1;\n        var LUrowi = new Array();\n        var LUcolj = new Array(m);\n        // Outer loop.\n        for (var j = 0; j < n; j++){\n            // Make a copy of the j-th column to localize references.\n            for (var i = 0; i < m; i++){\n                LUcolj[i] = LU[i][j];\n            }\n            // Apply previous transformations.\n            for (var i = 0; i < m; i++){\n                LUrowi = LU[i];\n                // Most of the time is spent in the following dot product.\n                var kmax = Math.min(i,j);\n                var s = 0;\n                for (var k = 0; k < kmax; k++){\n                    s += LUrowi[k]*LUcolj[k];\n                }\n                LUrowi[j] = LUcolj[i] -= s;\n            }\n            // Find pivot and exchange if necessary.\n            var p = j;\n            for (var i = j+1; i < m; i++){\n                if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])){\n                    p = i;\n                }\n            }\n            if (p != j){\n                for (var k = 0; k < n; k++){\n                    var t = LU[p][k];\n                    LU[p][k] = LU[j][k];\n                    LU[j][k] = t;\n                }\n                var k = piv[p];\n                piv[p] = piv[j];\n                piv[j] = k;\n                pivsign = -pivsign;\n            }\n            // Compute multipliers.\n            if (j < m & LU[j][j] != 0){\n                for (var i = j+1; i < m; i++){\n                    LU[i][j] /= LU[j][j];\n                }\n            }\n        }\n        if (B.length != m){\n            console.log('Matrix row dimensions must agree.');\n        }\n        for (var j = 0; j < n; j++){\n            if (LU[j][j] === 0){\n                console.log('Matrix is singular.')\n            }\n        }\n        var nx = B[0].length;\n        var X = mat.getMatrix(B,piv,0,nx-1);\n        // Solve L*Y = B(piv,:)\n        for (var k = 0; k < n; k++){\n            for (var i = k+1; i < n; i++){\n                for (var j = 0; j < nx; j++){\n                    X[i][j] -= X[k][j]*LU[i][k];\n                }\n            }\n        }\n        // Solve U*X = Y;\n        for (var k = n-1; k >= 0; k--){\n            for (var j = 0; j < nx; j++){\n                X[k][j] /= LU[k][k];\n            }\n            for (var i = 0; i < k; i++){\n                for (var j = 0; j < nx; j++){\n                    X[i][j] -= X[k][j]*LU[i][k];\n                }\n            }\n        }\n        return X;\n    },\n\n    /**\n     * Least squares solution of A*X = B, based on WEKA code\n     * @param {Array.<Array.<Number>>} A - left side matrix to be solved\n     * @param {Array.<Array.<Number>>} B - a matrix with as many rows as A and any number of columns.\n     * @return {Array.<Array.<Number>>} X - that minimizes the two norms of QR*X-B.\n     */\n    QRDecomposition(A, B) {\n        // Initialize.\n        var QR = new Array(A.length);\n\n        for (var i = 0; i < A.length; i++){\n            QR[i] = new Array(A[0].length);\n            for (var j = 0; j < A[0].length; j++){\n                QR[i][j] = A[i][j];\n            }\n        }\n        var m = A.length;\n        var n = A[0].length;\n        var Rdiag = new Array(n);\n        var nrm;\n\n        // Main loop.\n        for (var k = 0; k < n; k++){\n            // Compute 2-norm of k-th column without under/overflow.\n            nrm = 0;\n            for (var i = k; i < m; i++){\n                nrm = Math.hypot(nrm,QR[i][k]);\n            }\n            if (nrm != 0){\n                // Form k-th Householder vector.\n                if (QR[k][k] < 0){\n                    nrm = -nrm;\n                }\n                for (var i = k; i < m; i++){\n                    QR[i][k] /= nrm;\n                }\n                QR[k][k] += 1;\n\n                // Apply transformation to remaining columns.\n                for (var j = k+1; j < n; j++){\n                    var s = 0;\n                    for (var i = k; i < m; i++){\n                        s += QR[i][k]*QR[i][j];\n                    }\n                    s = -s/QR[k][k];\n                    for (var i = k; i < m; i++){\n                        QR[i][j] += s*QR[i][k];\n                    }\n                }\n            }\n            Rdiag[k] = -nrm;\n        }\n        if (B.length != m){\n            console.log('Matrix row dimensions must agree.');\n        }\n        for (var j = 0; j < n; j++){\n            if (Rdiag[j] === 0)\n                console.log('Matrix is rank deficient');\n        }\n        // Copy right hand side\n        var nx = B[0].length;\n        var X = new Array(B.length);\n        for(var i=0; i<B.length; i++){\n            X[i] = new Array(B[0].length);\n        }\n        for (var i = 0; i < B.length; i++){\n            for (var j = 0; j < B[0].length; j++){\n                X[i][j] = B[i][j];\n            }\n        }\n        // Compute Y = transpose(Q)*B\n        for (var k = 0; k < n; k++){\n            for (var j = 0; j < nx; j++){\n                var s = 0.0;\n                for (var i = k; i < m; i++){\n                    s += QR[i][k]*X[i][j];\n                }\n                s = -s/QR[k][k];\n                for (var i = k; i < m; i++){\n                    X[i][j] += s*QR[i][k];\n                }\n            }\n        }\n        // Solve R*X = Y;\n        for (var k = n-1; k >= 0; k--){\n            for (var j = 0; j < nx; j++){\n                X[k][j] /= Rdiag[k];\n            }\n            for (var i = 0; i < k; i++){\n                for (var j = 0; j < nx; j++){\n                    X[i][j] -= X[k][j]*QR[i][k];\n                }\n            }\n        }\n        return mat.getSubMatrix(X,0,n-1,0,nx-1);\n    }\n};\n\nexport default mat;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}